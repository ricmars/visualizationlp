---
description: Authoritative, condensed Cursor rules for lp-aws: coding standards, testing, DB/checkpoints, modal system, and LLM streaming/tooling.
globs:
  - "**/*"
alwaysApply: true
---

## TL;DR — Non‑negotiables

- Tests must be green before/after changes; add tests for new features
- No `any` anywhere; prefer `unknown` + type guards; explicit return types
- Database IDs are integers; `viewId` on steps is a number referencing Views.id
- Use npm and port 3100; do not use pnpm; do not use port 3000
- All DB writes go through checkpointed endpoints; do not bypass
- System prompt single source: import from `src/app/lib/databasePrompt.ts`
- Modals: render via `ModalPortal`, absolute positioning, overlay has `modal-overlay`, content has `role="dialog"`, respect z-index hierarchy
- Styling: no inline visual styles; use semantic classes in `src/app/globals.css` (dark modal surface uses `bg-[rgb(14,10,42)] text-white`)
- Quote SQL reserved words; use parameterized queries
- Streaming UI wiring lives in `src/app/api/openai/route.ts` using SSE

## Daily workflow checklist

1. `npm install` → `npm run dev` (port 3100)
2. Copy/update `.env.local` (Neon connection). Reset DB after schema changes: `curl -X POST http://localhost:3100/api/reset-db`
3. `npm test` before starting and after each meaningful change
4. Keep code style, types, and accessibility consistent
5. Use dynamic and checkpoint APIs for DB modifications

## Code style (TypeScript/React/Next)

- Functional, declarative components; avoid classes; small focused files (<200 lines)
- Naming: PascalCase components/types; camelCase vars/functions; UPPER_CASE constants
- Prefer explicit, descriptive names (e.g., `isLoading`, `hasError`)
- Organize by domain; export from barrel `index.ts`; split `types.ts` and `utils.ts`
- Hooks at top; grouped state; extract complex logic into custom hooks
- Next.js: use `<Link />` for internal nav, `<Image />` for images (width/height, alt, priority as needed)

## TypeScript rules

- Absolutely no `any`; use `unknown` and narrow with guards
- Explicit return types for exported functions; use generics; discriminated unions where appropriate
- Validate and guard at boundaries; create small custom error types

## Database and checkpoints

- Tables: "Objects", "Fields", "Views"; all IDs are integers generated by DB
- Relationships use integer IDs only; never names; keep numbers in memory and convert to string only for display
- Always parameterize queries; quote reserved keywords (e.g., "primary", "order")
- All POST/PUT/DELETE calls are automatically checkpointed at `/api/database` and dynamic API; LLM sessions can be grouped; UI/MCP are per‑operation
- See `docs/checkpoints.md` for behavior, rollback semantics, and performance notes

## Model validation (Objects/Steps/Views)

- Workflow object shape: `{ name: string, stages: Stage[], fields: Field[] }`
- Step type rules: only "Collect information" steps may have fields
- `viewId` requirement: collect steps MUST reference an existing database view via numeric `viewId: number`
- Views include `objectid` on creation; view names should be unique and descriptive; views can only reference fields belonging to their parent object

## Modals — required pattern

- Always render via `ModalPortal` into `#main-content-area` (not `document.body`)
- Use absolute positioning (never `fixed`) so modals are contained within the main content area
- Overlay: `absolute inset-0 bg-black/50 backdrop-blur-sm z-[80] modal-overlay`
- Content: `absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 z-[90]` with `role="dialog"`
- Z-index order: base `z-0..10` < overlay `z-[80]` < content `z-[90]` < selection overlay `z-[100]` < quick chat `z-[110]`
- Dark theme: use semantic classes from `globals.css` (no inline styles)
- Scrolling: for tall content, make the inner body scrollable, not the overlay
- See `docs/modals.md` for the minimal snippet and checklist

## Performance

- Favor RSC/SSR; minimize `'use client'`, `useEffect`, `setState`
- Code split with dynamic imports; lazy load; memoize expensive components
- Use proper keys in lists; debounce/throttle input‑heavy handlers
- Optimize images (WebP, sizes, priority where needed)

## LLM/OpenAI and streaming

- Wire streaming via SSE in `src/app/api/openai/route.ts` with `processor.sendText()`; set/reset `isThinking`
- Keep the system prompt centralized (see above)
- Tool usage is source of truth; confirm destructive actions explicitly when ambiguous
- See `docs/llm-streaming.md` for the SSE details and UX cues

## State management and data fetching

- Prefer TanStack Query for server state; clear loading/error states; proper caching
- Keep server components pure; isolate client state

## Security

- Input validation and sanitization; CSRF protection; OWASP basics; env vars for secrets; rate limiting as appropriate

## Testing (single policy)

- Run tests frequently; fix failures immediately; write tests for new features
- Test files live in `__tests__` adjacent to code and use Jest + TypeScript
- No test‑only code in production files; production runs without `jest`
- Commands: `npm test`, `npm test --ci --runInBand`, `npm test --watch`, `npm test --coverage`
- See `docs/testing.md` for patterns and examples

## Gotchas (consolidated)

- Use npm (not pnpm) and port 3100 everywhere
- Do not duplicate the system prompt; import it
- Do not bypass checkpointing for DB modifications
- Quote reserved SQL keywords consistently
- Use integer IDs only for DB relations (`viewId` is a number)
- Modals must use portal + absolute + overlay class + role + z-index order

## References

- System prompt: `src/app/lib/databasePrompt.ts`
- Streaming route: `src/app/api/openai/route.ts`
- Modal portal: `src/app/components/ModalPortal.tsx`
- Context filter: `src/app/application/[id]/hooks/useFreeFormSelection.ts`
- Dynamic API and registry: `src/app/api/dynamic/route.ts`, `src/app/types/ruleTypeRegistry.ts`, `src/app/types/ruleTypeDefinitions.ts`
- Docs: `docs/modals.md`, `docs/checkpoints.md`, `docs/rule-types.md`, `docs/testing.md`, `docs/llm-streaming.md`
